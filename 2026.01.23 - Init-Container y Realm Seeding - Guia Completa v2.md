# Gu√≠a: Init-Container y Realm Seeding en Keycloak (v2)

**Fecha:** 23 de Enero de 2026  
**Tema:** Funcionamiento del Init-Container y actualizaci√≥n correcta de URLs en Keycloak  
**Versi√≥n:** 2.0 - Incluye soluciones 4a y 4b

---

## √çndice

1. [Descripci√≥n del Problema](#descripci√≥n-del-problema)
2. [Arquitectura del Sistema](#arquitectura-del-sistema)
3. [Flujo de Inicializaci√≥n de Keycloak](#flujo-de-inicializaci√≥n-de-keycloak)
4. [El Problema con tx.test](#el-problema-con-txtest)
5. [Soluciones Disponibles](#soluciones-disponibles)
   - [Soluci√≥n 1: Deshabilitar Init-Container](#soluci√≥n-1-deshabilitar-el-init-container)
   - [Soluci√≥n 2: Crear Init-Container Personalizado](#soluci√≥n-2-crear-init-container-personalizado)
   - [Soluci√≥n 3: Job de Correcci√≥n Post-Despliegue](#soluci√≥n-3-job-de-correcci√≥n-post-despliegue)
   - [Soluci√≥n 4a: ConfigMap con JSON Generados](#soluci√≥n-4a-configmap-con-json-generados-‚≠ê-nueva)
   - [Soluci√≥n 4b: Script de Transformaci√≥n Runtime](#soluci√≥n-4b-script-de-transformaci√≥n-runtime-‚≠ê-nueva)
6. [Tabla Comparativa de Soluciones](#tabla-comparativa-de-soluciones)
7. [Recomendaci√≥n Final](#recomendaci√≥n-final)

---

## Descripci√≥n del Problema

Al desplegar el portal de Tractus-X en OVH con una nueva IP del LoadBalancer, las URLs en la base de datos de Keycloak mantienen valores antiguos (`tx.test`) en lugar de actualizarse con la nueva IP.

### URLs afectadas encontradas:

**En Central IDP (11 URLs):**
- `portal.tx.test` - 4 ocurrencias
- `sharedidp.tx.test` - 4 ocurrencias
- `partners-gate.tx.test` - 1 ocurrencia
- `partners-pool.tx.test` - 1 ocurrencia
- `managed-identity-wallets.tx.test` - 1 ocurrencia

**En Shared IDP (2 URLs):**
- `centralidp.tx.test` - 2 ocurrencias

---

## Arquitectura del Sistema

### Componentes involucrados:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Helm Chart Deployment                     ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  1. values-adopter-portal.yaml    ‚Üí Habilita componentes    ‚îÇ
‚îÇ  2. values-ovh-hosts-portal.yaml  ‚Üí Config de infraestructura‚îÇ
‚îÇ  3. values-ovh-realms-portal.yaml ‚Üí Config de realm seeding ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Kubernetes Pod: Keycloak (StatefulSet)          ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   Init Container 1: prepare-write-dirs             ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   - Prepara directorios y permisos                 ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                           ‚Üì                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   Init Container 2: import                         ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   - Imagen: umbrella-init-container:2.3.0-init    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   - Contiene: CX-Central-realm.json               ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   - Contiene: CX-Central-users-0.json             ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   - Copia archivos JSON a /import/                ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                           ‚Üì                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ   Main Container: keycloak                         ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   1. Lee archivos JSON de /import/                ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   2. Importa realms a PostgreSQL                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   3. Ejecuta realm seeding (si configurado)       ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            PostgreSQL Database (PersistentVolume)            ‚îÇ
‚îÇ                                                               ‚îÇ
‚îÇ  - Tablas: client, redirect_uris, identity_provider_config  ‚îÇ
‚îÇ  - Datos: URLs hardcodeadas desde JSON del init-container   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Flujo de Inicializaci√≥n de Keycloak

### Paso 1: Build del Init-Container

**Ubicaci√≥n:** `init-container/Dockerfile`

```dockerfile
FROM alpine:3.19
RUN mkdir import
RUN chown -R 1000:3000 /import
USER 1000:3000
COPY iam/centralidp/ import/catenax-central/realms
```

**Archivos copiados:**
- `init-container/iam/centralidp/CX-Central-realm.json`
- `init-container/iam/centralidp/CX-Central-users-0.json`

### Paso 2: Despliegue del StatefulSet de Keycloak

Cuando se despliega el Helm chart, se crea un StatefulSet con:

1. **Init Container 1: prepare-write-dirs**
   - Prepara directorios con permisos correctos

2. **Init Container 2: import** 
   - Usa la imagen: `docker.io/tractusx/umbrella-init-container:2.3.0-init`
   - Monta un volumen compartido en `/import/`
   - Copia los archivos JSON al volumen

### Paso 3: Arranque de Keycloak

El contenedor principal de Keycloak:

1. **Lee los archivos JSON** del volumen `/import/`
2. **Importa el realm completo** a PostgreSQL:
   - Clientes (clients)
   - URLs de redirecci√≥n (redirect_uris)
   - Configuraci√≥n de Identity Providers
   - Usuarios
   - Roles
   - etc.

3. **Ejecuta realm seeding** (si est√° configurado en values):
   - **IMPORTANTE:** El realm seeding es **idempotente**
   - Solo **crea** recursos que NO existen
   - **NO actualiza** recursos existentes en la BD

### Paso 4: Estado Final

La base de datos PostgreSQL contiene:
- ‚úÖ Todos los datos del realm importados desde JSON
- ‚ö†Ô∏è URLs con valores hardcodeados del JSON (`tx.test`)
- ‚ùå Los valores del realm seeding NO sobrescriben datos existentes

---

## El Problema con tx.test

### Causa Ra√≠z

Los archivos JSON del init-container tienen URLs hardcodeadas:

**Archivo:** `init-container/iam/centralidp/CX-Central-realm.json`

```json
{
  "clients": [
    {
      "clientId": "Cl2-CX-Portal",
      "rootUrl": "http://portal.tx.test/home",
      "redirectUris": [
        "http://portal.tx.test/*"
      ]
    }
  ],
  "identityProviders": [
    {
      "alias": "CX-Operator",
      "config": {
        "tokenUrl": "http://sharedidp.tx.test/auth/realms/CX-Operator/protocol/openid-connect/token",
        "authorizationUrl": "http://sharedidp.tx.test/auth/realms/CX-Operator/protocol/openid-connect/auth"
      }
    }
  ]
}
```

### Secuencia del Problema

```
1. Init-container copia JSON con tx.test
              ‚Üì
2. Keycloak importa JSON ‚Üí BD tiene tx.test
              ‚Üì
3. Realm seeding intenta actualizar
              ‚Üì
4. Realm seeding detecta que el recurso existe
              ‚Üì
5. Realm seeding NO actualiza (es idempotente)
              ‚Üì
6. BD mantiene valores con tx.test ‚ùå
```

---

## Soluciones Disponibles

---

### Soluci√≥n 1: Deshabilitar el Init-Container

**Ventajas:**
- ‚úÖ Simple de implementar
- ‚úÖ El realm seeding crea todo desde cero con URLs correctas
- ‚úÖ No requiere construir im√°genes custom
- ‚úÖ Funciona con valores din√°micos (cualquier IP)

**Desventajas:**
- ‚ö†Ô∏è Requiere eliminar la base de datos existente para empezar limpio
- ‚ö†Ô∏è Se pierden datos previos (usuarios, configuraciones manuales)
- ‚ö†Ô∏è Puede faltar configuraci√≥n avanzada del realm original

**Implementaci√≥n:**

Agregar a `values-ovh-realms-portal.yaml`:

```yaml
centralidp:
  keycloak:
    realmSeeding:
      initContainer:
        image:
          name: ""  # Deshabilita el init-container
      # ... resto de configuraci√≥n de realmSeeding
```

**Pasos:**

1. Agregar configuraci√≥n para deshabilitar init-container
2. Eliminar el namespace completo: `kubectl delete namespace portal`
3. Redesplegar con:
   ```bash
   helm install portal . \
     -f values-adopter-portal.yaml \
     -f values-ovh-hosts-portal.yaml \
     -f values-ovh-realms-portal.yaml \
     -n portal \
     --create-namespace
   ```

---

### Soluci√≥n 2: Crear Init-Container Personalizado

**Ventajas:**
- ‚úÖ Mantiene toda la configuraci√≥n original del realm
- ‚úÖ Puede incluir datos adicionales (usuarios custom, etc.)
- ‚úÖ No requiere borrar datos existentes despu√©s de la primera vez

**Desventajas:**
- ‚ùå Requiere construir y mantener imagen Docker personalizada
- ‚ùå M√°s complejo de implementar
- ‚ùå Requiere registro de im√°genes (Docker Hub, registry privado, etc.)
- ‚ùå Los JSONs quedan hardcodeados con una IP espec√≠fica

**Implementaci√≥n:**

1. **Crear archivos JSON customizados:**

   ```bash
   # Copiar archivos originales
   cp init-container/iam/centralidp/CX-Central-realm.json \
      init-container/iam/centralidp/CX-Central-realm-ovh.json
   
   # Reemplazar tx.test con tu IP
   sed -i 's/tx\.test/51.83.111.178.nip.io/g' \
      init-container/iam/centralidp/CX-Central-realm-ovh.json
   ```

2. **Construir imagen Docker personalizada:**

   ```dockerfile
   FROM alpine:3.19
   RUN mkdir import
   RUN chown -R 1000:3000 /import
   USER 1000:3000
   COPY iam/centralidp-ovh/ import/catenax-central/realms
   ```

3. **Build y push:**

   ```bash
   cd init-container
   docker build -t myregistry/umbrella-init-container:ovh-custom .
   docker push myregistry/umbrella-init-container:ovh-custom
   ```

4. **Usar en values:**

   ```yaml
   centralidp:
     keycloak:
       realmSeeding:
         initContainer:
           image:
             name: myregistry/umbrella-init-container:ovh-custom
             pullPolicy: Always
   ```

---

### Soluci√≥n 3: Job de Correcci√≥n Post-Despliegue

**Ventajas:**
- ‚úÖ No requiere reconstruir nada
- ‚úÖ Funciona con despliegue existente
- ‚úÖ Puede ejecutarse m√∫ltiples veces

**Desventajas:**
- ‚ùå Es un workaround, no una soluci√≥n permanente
- ‚ùå Requiere paso manual despu√©s de cada despliegue
- ‚ùå Necesita reiniciar pods despu√©s de corregir

**Ya implementado:** `fix-keycloak-urls-job-complete.yaml`

**Uso:**
```bash
kubectl apply -f fix-keycloak-urls-job-complete.yaml -n portal
kubectl logs -n portal job/fix-keycloak-urls-complete -f
kubectl delete pod -n portal -l app.kubernetes.io/name=centralidp
kubectl delete pod -n portal -l app.kubernetes.io/name=sharedidp
```

---

### Soluci√≥n 4a: ConfigMap con JSON Generados ‚≠ê NUEVA

**Descripci√≥n:**  
Generar los archivos JSON localmente con las URLs correctas y subirlos a Kubernetes como ConfigMap. El init-container los monta y Keycloak los importa.

**Ventajas:**
- ‚úÖ No requiere construir imagen Docker
- ‚úÖ No requiere Docker registry
- ‚úÖ Mantiene TODA la configuraci√≥n del realm original
- ‚úÖ Cambios r√°pidos (solo kubectl apply)
- ‚úÖ Funciona con cualquier IP (regeneras el ConfigMap)
- ‚úÖ Puedes versionar los JSON en Git
- ‚úÖ F√°cil de automatizar con scripts

**Desventajas:**
- ‚ö†Ô∏è Requiere regenerar ConfigMap para cada cambio de IP
- ‚ö†Ô∏è Los JSON son grandes (~5000 l√≠neas cada uno)
- ‚ö†Ô∏è ConfigMaps tienen l√≠mite de tama√±o (1MB, pero suficiente)

**Implementaci√≥n Detallada:**

#### Paso 1: Crear script de generaci√≥n

**Archivo:** `charts/umbrella/generate-realm-configmap.sh`

```bash
#!/bin/bash
# Script para generar ConfigMaps con realms customizados
# Uso: ./generate-realm-configmap.sh 51.83.111.178 .nip.io

set -e

LOAD_BALANCER_IP=${1:-"51.83.111.178"}
DNS_SUFFIX=${2:-".nip.io"}
TARGET_DOMAIN="${LOAD_BALANCER_IP}${DNS_SUFFIX}"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../../" && pwd)"
TEMP_DIR="/tmp/keycloak-realms-custom"

echo "================================================"
echo "Generando realms customizados para Keycloak"
echo "================================================"
echo "IP LoadBalancer: $LOAD_BALANCER_IP"
echo "DNS Suffix: $DNS_SUFFIX"
echo "Target Domain: $TARGET_DOMAIN"
echo ""

# Crear directorio temporal
rm -rf "$TEMP_DIR"
mkdir -p "$TEMP_DIR/centralidp"
mkdir -p "$TEMP_DIR/sharedidp"

# Generar JSON para Central IDP
echo "Generando CX-Central-realm.json..."
sed "s/tx\.test/${TARGET_DOMAIN}/g" \
    "$PROJECT_ROOT/init-container/iam/centralidp/CX-Central-realm.json" \
    > "$TEMP_DIR/centralidp/CX-Central-realm.json"

echo "Generando CX-Central-users-0.json..."
sed "s/tx\.test/${TARGET_DOMAIN}/g" \
    "$PROJECT_ROOT/init-container/iam/centralidp/CX-Central-users-0.json" \
    > "$TEMP_DIR/centralidp/CX-Central-users-0.json"

# Verificar que se generaron correctamente
echo ""
echo "Verificando archivos generados..."
if grep -q "tx\.test" "$TEMP_DIR/centralidp/"*.json; then
    echo "‚ùå ERROR: Todav√≠a hay referencias a tx.test en los archivos generados"
    exit 1
fi

echo "‚úÖ Archivos generados correctamente"
echo ""
echo "Archivos generados en: $TEMP_DIR"
ls -lh "$TEMP_DIR/centralidp/"

echo ""
echo "================================================"
echo "Para aplicar, ejecuta:"
echo "================================================"
echo "kubectl create configmap centralidp-realm-custom \\"
echo "  --from-file=$TEMP_DIR/centralidp/ \\"
echo "  -n portal \\"
echo "  --dry-run=client -o yaml | kubectl apply -f -"
echo ""
```

#### Paso 2: Ejecutar script de generaci√≥n

```bash
cd /home/xmendialdua/projects/assembly/tractus-x-umbrella/charts/umbrella

# Dar permisos de ejecuci√≥n
chmod +x generate-realm-configmap.sh

# Generar archivos para tu IP
./generate-realm-configmap.sh 51.83.111.178 .nip.io
```

#### Paso 3: Crear ConfigMap en Kubernetes

```bash
# Crear o actualizar el ConfigMap
kubectl create configmap centralidp-realm-custom \
  --from-file=/tmp/keycloak-realms-custom/centralidp/ \
  -n portal \
  --dry-run=client -o yaml | kubectl apply -f -

# Verificar que se cre√≥
kubectl get configmap centralidp-realm-custom -n portal
kubectl describe configmap centralidp-realm-custom -n portal | head -20
```

#### Paso 4: Modificar el Helm chart para usar ConfigMap

**Opci√≥n A: Modificar values para montar ConfigMap**

Agregar a `values-ovh-realms-portal.yaml`:

```yaml
centralidp:
  keycloak:
    # Montar ConfigMap con realms customizados
    extraVolumes:
      - name: realm-custom
        configMap:
          name: centralidp-realm-custom
    
    # El init-container debe copiar desde este volumen
    initContainers:
      - name: copy-custom-realm
        image: busybox:1.36
        command:
          - sh
          - -c
          - |
            echo "Copiando realms customizados..."
            cp -v /realm-custom/* /import/catenax-central/realms/
            echo "Listando archivos copiados:"
            ls -lh /import/catenax-central/realms/
        volumeMounts:
          - name: realm-custom
            mountPath: /realm-custom
          - name: realm-import
            mountPath: /import
```

**Opci√≥n B: Deshabilitar init-container original y usar solo ConfigMap**

```yaml
centralidp:
  keycloak:
    realmSeeding:
      initContainer:
        image:
          name: ""  # Deshabilitar init-container original
    
    # Usar nuestro propio init-container
    initContainers:
      - name: import-from-configmap
        image: busybox:1.36
        command:
          - sh
          - -c
          - |
            mkdir -p /import/catenax-central/realms
            cp /realm-custom/* /import/catenax-central/realms/
            chown -R 1000:3000 /import
        volumeMounts:
          - name: realm-custom
            mountPath: /realm-custom
          - name: realm-import
            mountPath: /import
    
    extraVolumes:
      - name: realm-custom
        configMap:
          name: centralidp-realm-custom
```

#### Paso 5: Desplegar

```bash
# Si es primera vez, crear ConfigMap primero
kubectl create configmap centralidp-realm-custom \
  --from-file=/tmp/keycloak-realms-custom/centralidp/ \
  -n portal

# Luego desplegar con Helm
helm upgrade portal . \
  -f values-adopter-portal.yaml \
  -f values-ovh-hosts-portal.yaml \
  -f values-ovh-realms-portal.yaml \
  -n portal
```

#### Ventajas de esta soluci√≥n:

1. **Flexibilidad total**: Puedes cambiar de IP regenerando el ConfigMap
2. **Sin Docker registry**: Todo se maneja en Kubernetes
3. **Scriptable**: Un solo comando para generar todo
4. **Versionable**: Puedes guardar los JSON generados en Git
5. **Config completa**: Mantienes TODO el realm original

---

### Soluci√≥n 4b: Script de Transformaci√≥n Runtime ‚≠ê NUEVA

**Descripci√≥n:**  
Usar el init-container existente pero agregar un script que transforme los JSON en tiempo de ejecuci√≥n antes de que Keycloak los importe.

**Ventajas:**
- ‚úÖ Usa la imagen init-container original (no custom)
- ‚úÖ No requiere Docker registry
- ‚úÖ Transformaci√≥n din√°mica en cada despliegue
- ‚úÖ Mantiene TODA la configuraci√≥n original
- ‚úÖ Las variables vienen de Kubernetes (env vars)
- ‚úÖ Soluci√≥n "cloud-native"

**Desventajas:**
- ‚ö†Ô∏è M√°s complejo de configurar en Helm chart
- ‚ö†Ô∏è Requiere modificar el comportamiento del init-container v√≠a Helm
- ‚ö†Ô∏è Depende de que el chart permita overrides de command

**Implementaci√≥n Detallada:**

#### Paso 1: Crear ConfigMap con script de transformaci√≥n

**Archivo:** `realm-transform-script.yaml`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: realm-transform-script
  namespace: portal
data:
  transform.sh: |
    #!/bin/sh
    set -e
    
    echo "========================================"
    echo "Transformando realms con URLs correctas"
    echo "========================================"
    echo "Target: ${TARGET_DOMAIN}"
    echo ""
    
    # Directorio de trabajo
    IMPORT_DIR="/import/catenax-central/realms"
    TEMP_DIR="/tmp/realms-transformed"
    
    mkdir -p "$TEMP_DIR"
    
    # Copiar archivos originales
    echo "Copiando archivos originales..."
    cp -v "$IMPORT_DIR"/* "$TEMP_DIR/" || true
    
    # Transformar todos los JSON
    echo "Transformando archivos JSON..."
    for file in "$TEMP_DIR"/*.json; do
        if [ -f "$file" ]; then
            echo "  Procesando: $(basename $file)"
            sed -i "s/tx\.test/${TARGET_DOMAIN}/g" "$file"
        fi
    done
    
    # Verificar transformaci√≥n
    echo ""
    echo "Verificando transformaci√≥n..."
    if grep -r "tx\.test" "$TEMP_DIR"/*.json 2>/dev/null; then
        echo "‚ùå ERROR: Todav√≠a hay tx.test en los archivos"
        exit 1
    fi
    
    # Copiar de vuelta
    echo "‚úÖ Transformaci√≥n exitosa"
    echo "Copiando archivos transformados..."
    cp -v "$TEMP_DIR"/* "$IMPORT_DIR/"
    
    echo ""
    echo "Archivos finales en $IMPORT_DIR:"
    ls -lh "$IMPORT_DIR"
    echo ""
    echo "Primeras l√≠neas de CX-Central-realm.json:"
    head -20 "$IMPORT_DIR/CX-Central-realm.json"
```

Aplicar:
```bash
kubectl apply -f realm-transform-script.yaml
```

#### Paso 2: Modificar values para usar el script

Agregar a `values-ovh-realms-portal.yaml`:

```yaml
centralidp:
  keycloak:
    realmSeeding:
      # Mantener el init-container original
      initContainer:
        image:
          name: docker.io/tractusx/umbrella-init-container:2.3.0-init
          pullPolicy: IfNotPresent
      
      # Agregar init-container adicional DESPU√âS del original
      extraInitContainers:
        - name: transform-realm-urls
          image: busybox:1.36
          env:
            - name: TARGET_DOMAIN
              value: "51.83.111.178.nip.io"  # O desde ConfigMap
          command:
            - sh
            - /scripts/transform.sh
          volumeMounts:
            - name: realm-import
              mountPath: /import
            - name: transform-script
              mountPath: /scripts
      
      extraVolumes:
        - name: transform-script
          configMap:
            name: realm-transform-script
            defaultMode: 0755
```

#### Paso 3: Alternativa con valores din√°micos

Para hacer el TARGET_DOMAIN din√°mico desde ConfigMap:

```yaml
# ConfigMap con configuraci√≥n
apiVersion: v1
kind: ConfigMap
metadata:
  name: portal-config
  namespace: portal
data:
  LOAD_BALANCER_IP: "51.83.111.178"
  DNS_SUFFIX: ".nip.io"
```

Y en values:

```yaml
centralidp:
  keycloak:
    realmSeeding:
      extraInitContainers:
        - name: transform-realm-urls
          image: busybox:1.36
          env:
            - name: LOAD_BALANCER_IP
              valueFrom:
                configMapKeyRef:
                  name: portal-config
                  key: LOAD_BALANCER_IP
            - name: DNS_SUFFIX
              valueFrom:
                configMapKeyRef:
                  name: portal-config
                  key: DNS_SUFFIX
          command:
            - sh
            - -c
            - |
              export TARGET_DOMAIN="${LOAD_BALANCER_IP}${DNS_SUFFIX}"
              sh /scripts/transform.sh
          volumeMounts:
            - name: realm-import
              mountPath: /import
            - name: transform-script
              mountPath: /scripts
```

#### Paso 4: Desplegar

```bash
# 1. Crear ConfigMap con script
kubectl apply -f realm-transform-script.yaml

# 2. Crear ConfigMap con configuraci√≥n (opcional)
kubectl apply -f portal-config.yaml

# 3. Desplegar con Helm
helm upgrade portal . \
  -f values-adopter-portal.yaml \
  -f values-ovh-hosts-portal.yaml \
  -f values-ovh-realms-portal.yaml \
  -n portal
```

#### Paso 5: Verificar que funciona

```bash
# Ver logs del init-container de transformaci√≥n
kubectl logs -n portal portal-centralidp-0 -c transform-realm-urls

# Debe mostrar:
# ========================================
# Transformando realms con URLs correctas
# ========================================
# Target: 51.83.111.178.nip.io
# ...
# ‚úÖ Transformaci√≥n exitosa
```

#### Ventajas de esta soluci√≥n:

1. **Totalmente Kubernetes-native**: Todo se gestiona con K8s resources
2. **Sin builds**: Usa im√°genes est√°ndar
3. **Din√°mico**: Las URLs vienen de ConfigMaps
4. **Auditable**: Logs claros de la transformaci√≥n
5. **Mantenible**: El script est√° en un ConfigMap versionable

---

## Tabla Comparativa de Soluciones

| Criterio | Sol. 1<br>Deshabilitar | Sol. 2<br>Build Custom | Sol. 3<br>Job Post-Deploy | Sol. 4a<br>ConfigMap | Sol. 4b<br>Transform Runtime |
|----------|------------------------|------------------------|---------------------------|----------------------|------------------------------|
| **Complejidad** | ‚≠ê Baja | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê‚≠ê Media | ‚≠ê‚≠ê Media | ‚≠ê‚≠ê‚≠ê Media-Alta |
| **Requiere borrar NS** | ‚úÖ S√≠ | ‚ö†Ô∏è Primera vez | ‚ùå No | ‚ö†Ô∏è Primera vez | ‚ö†Ô∏è Primera vez |
| **Requiere registry** | ‚ùå No | ‚úÖ S√≠ | ‚ùå No | ‚ùå No | ‚ùå No |
| **Config completa realm** | ‚ö†Ô∏è Parcial | ‚úÖ Total | ‚úÖ Total | ‚úÖ Total | ‚úÖ Total |
| **Flexibilidad IP** | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê Baja | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê‚≠ê‚≠ê Alta |
| **Mantenibilidad** | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê Baja | ‚≠ê‚≠ê Media | ‚≠ê‚≠ê‚≠ê Alta | ‚≠ê‚≠ê Media |
| **Tiempo setup inicial** | 5 min | 30 min | 5 min | 15 min | 20 min |
| **Tiempo cambio IP** | 10 min | 30 min | 5 min | 5 min | 2 min |
| **Soluci√≥n permanente** | ‚úÖ S√≠ | ‚úÖ S√≠ | ‚ùå No | ‚úÖ S√≠ | ‚úÖ S√≠ |
| **Cloud-native** | ‚≠ê‚≠ê‚≠ê S√≠ | ‚≠ê No | ‚≠ê‚≠ê Parcial | ‚≠ê‚≠ê‚≠ê S√≠ | ‚≠ê‚≠ê‚≠ê S√≠ |
| **Versionable en Git** | ‚úÖ S√≠ | ‚ö†Ô∏è Parcial | ‚úÖ S√≠ | ‚úÖ S√≠ | ‚úÖ S√≠ |
| **Errores comunes** | Faltan configs | Build/Push fail | Olvido ejecutar | ConfigMap size | Script errors |
| **Rollback facilidad** | ‚≠ê‚≠ê Media | ‚≠ê Dif√≠cil | ‚≠ê‚≠ê‚≠ê F√°cil | ‚≠ê‚≠ê‚≠ê F√°cil | ‚≠ê‚≠ê Media |

### Puntuaci√≥n total (0-10):

| Soluci√≥n | Puntuaci√≥n | Recomendaci√≥n |
|----------|------------|---------------|
| **Sol. 4a - ConfigMap** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **9.5/10** | **MEJOR para entornos cloud** |
| **Sol. 4b - Transform** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê **9.0/10** | **Alternativa elegante** |
| **Sol. 1 - Deshabilitar** | ‚≠ê‚≠ê‚≠ê‚≠ê **8.0/10** | Buena si no necesitas config completa |
| **Sol. 3 - Job Post** | ‚≠ê‚≠ê‚≠ê **6.0/10** | Workaround temporal aceptable |
| **Sol. 2 - Build Custom** | ‚≠ê‚≠ê **5.0/10** | Solo si tienes registry privado |

---

## Recomendaci√≥n Final

### Escenario 1: Quieres la mejor soluci√≥n t√©cnica
**üëâ Soluci√≥n 4a - ConfigMap con JSON Generados**

**Razones:**
- ‚úÖ Mantiene configuraci√≥n completa del realm
- ‚úÖ No requiere Docker registry
- ‚úÖ F√°cil de automatizar
- ‚úÖ Scriptable y reproducible
- ‚úÖ Cambios de IP r√°pidos (5 minutos)

**Implementaci√≥n:**
1. Ejecutar script `generate-realm-configmap.sh`
2. Aplicar ConfigMap
3. Modificar values para usar ConfigMap
4. Desplegar

### Escenario 2: Quieres m√°xima elegancia cloud-native
**üëâ Soluci√≥n 4b - Script de Transformaci√≥n Runtime**

**Razones:**
- ‚úÖ Todo gestionado en Kubernetes
- ‚úÖ URLs din√°micas desde ConfigMaps
- ‚úÖ Sin archivos intermedios
- ‚úÖ Transformaci√≥n auditable (logs)

**Trade-off:**
- M√°s compleja de configurar inicialmente
- Requiere entender bien init-containers

### Escenario 3: Quieres simplicidad m√°xima
**üëâ Soluci√≥n 1 - Deshabilitar Init-Container**

**Razones:**
- ‚úÖ Implementaci√≥n en 5 minutos
- ‚úÖ Configuraci√≥n clara en values
- ‚úÖ No requiere scripts adicionales

**Trade-off:**
- Requiere borrar namespace (p√©rdida de datos)
- Puede faltar configuraci√≥n avanzada

---

## Plan de Implementaci√≥n Recomendado

### Para tu caso espec√≠fico (OVH con IP din√°mica):

**Recomiendo Soluci√≥n 4a** porque:

1. Tienes control total del realm
2. Puedes cambiar de IP f√°cilmente
3. No necesitas registry Docker
4. Es scriptable ‚Üí puedes automatizar
5. Los JSON se pueden versionar en Git

### Pasos para implementar Soluci√≥n 4a:

```bash
# 1. Crear script de generaci√≥n (ya documentado arriba)
cd /home/xmendialdua/projects/assembly/tractus-x-umbrella/charts/umbrella

# 2. Generar JSON customizados
./generate-realm-configmap.sh 51.83.111.178 .nip.io

# 3. Crear ConfigMap
kubectl create configmap centralidp-realm-custom \
  --from-file=/tmp/keycloak-realms-custom/centralidp/ \
  -n portal \
  --dry-run=client -o yaml | kubectl apply -f -

# 4. Modificar values-ovh-realms-portal.yaml
# (agregar configuraci√≥n de extraVolumes y extraInitContainers)

# 5. Desplegar
helm upgrade portal . \
  -f values-adopter-portal.yaml \
  -f values-ovh-hosts-portal.yaml \
  -f values-ovh-realms-portal.yaml \
  -n portal
```

---

**√öltima actualizaci√≥n:** 23 de Enero 2026  
**Versi√≥n:** 2.0  
**Autor:** Asistente AI / GitHub Copilot
